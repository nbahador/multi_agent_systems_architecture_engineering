this html is not complete. complete it and give full revised code. all lines. end to end html code. "write a profesional html, HTML acts like an interactive textbook that teaches what the code does and how to use or customize it, not just showing raw code.. with white background, Table of Contents, Visual Diagrams, Collapsible Sections, Syntax Highlighting, Inline Explanations, Step-by-Step Guide: Break the code into logical chunks with headers and descriptive text before each section., Interactive mock demos of each step (runnable input-output mock demos), Code vs. Explanation Layout: Show code on one side, matching explanations on the other for easy reference., Responsive & Accessible Design.". this is the html incomoplte code "<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Agent System with Cooldown - Interactive Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: white;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .toc {
            position: sticky;
            top: 20px;
            height: fit-content;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
        }
        
        .toc h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .toc ul {
            list-style: none;
        }
        
        .toc li {
            margin-bottom: 8px;
        }
        
        .toc a {
            color: #3498db;
            text-decoration: none;
            font-size: 0.9rem;
            padding: 5px 0;
            display: block;
            transition: color 0.2s;
        }
        
        .toc a:hover {
            color: #2980b9;
        }
        
        .content {
            background: white;
        }
        
        .header {
            text-align: center;
            padding: 40px 0;
            border-bottom: 3px solid #3498db;
            margin-bottom: 40px;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.2rem;
        }
        
        .section {
            margin-bottom: 50px;
        }
        
        .section h2 {
            color: #2c3e50;
            font-size: 2rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }
        
        .section h3 {
            color: #34495e;
            font-size: 1.5rem;
            margin: 25px 0 15px 0;
        }
        
        .collapsible {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .collapsible-header {
            padding: 15px 20px;
            cursor: pointer;
            background: #e9ecef;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .collapsible-header:hover {
            background: #dee2e6;
        }
        
        .collapsible-content {
            padding: 20px;
            display: none;
        }
        
        .collapsible.active .collapsible-content {
            display: block;
        }
        
        .collapsible.active .collapsible-header::after {
            content: '▼';
        }
        
        .collapsible-header::after {
            content: '▶';
            font-size: 0.8em;
        }
        
        .code-explanation {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .code-side {
            background: #f8f9fa;
            padding: 20px;
        }
        
        .explanation-side {
            padding: 20px;
            background: white;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .highlight {
            background: #ffeaa7;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .demo-box {
            background: #f1f2f6;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .demo-box h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .input-box, .output-box {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        
        .input-box {
            border-left: 4px solid #27ae60;
        }
        
        .output-box {
            border-left: 4px solid #e74c3c;
            background: #fdf2f2;
        }
        
        .diagram {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .flow-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .flow-box {
            background: #3498db;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            min-width: 120px;
            text-align: center;
            font-weight: bold;
        }
        
        .flow-arrow {
            font-size: 1.5rem;
            color: #7f8c8d;
        }
        
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-left: 4px solid #f39c12;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-left: 4px solid #28a745;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .button:hover {
            background: #2980b9;
        }
        
        .interactive-demo {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid #3498db;
            border-radius: 10px;
            background: #f8f9fa;
        }
        
        .demo-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .toc {
                position: static;
                margin-bottom: 20px;
            }
            
            .code-explanation {
                grid-template-columns: 1fr;
            }
            
            .flow-diagram {
                flex-direction: column;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
        
        .syntax-python { color: #ff6b6b; }
        .syntax-string { color: #4ecdc4; }
        .syntax-comment { color: #95a5a6; font-style: italic; }
        .syntax-keyword { color: #e74c3c; font-weight: bold; }
        .syntax-number { color: #f39c12; }
    </style>
</head>
<body>
    <div class="container">
        <nav class="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#overview">System Overview</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#configuration">Configuration</a></li>
                <li><a href="#cooldown">Cooldown System</a></li>
                <li><a href="#tools">Tool Setup</a></li>
                <li><a href="#agents">Creating Agents</a></li>
                <li><a href="#orchestration">Orchestration</a></li>
                <li><a href="#deployment">Deployment</a></li>
                <li><a href="#examples">Complete Examples</a></li>
                <li><a href="#customization">Customization Guide</a></li>
            </ul>
        </nav>
        
        <main class="content">
            <header class="header">
                <h1>Multi-Agent System with Cooldown</h1>
                <p>Interactive Guide & Tutorial</p>
            </header>
            
            <section id="overview" class="section">
                <h2>System Overview</h2>
                <p>This template helps you create intelligent multi-agent systems where AI agents work together to accomplish complex tasks. Each agent has a specific role, and they can use external tools and communicate with each other.</p>
                
                <div class="info-box">
                    <strong>What makes this special:</strong> Built-in cooldown system prevents overuse, modular design allows easy customization, and MCP tools integration provides powerful external capabilities.
                </div>
                
                <div class="diagram">
                    <h3>System Flow</h3>
                    <div class="flow-diagram">
                        <div class="flow-box">User Request</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-box">Cooldown Check</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-box">Agent 1</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-box">Agent 2</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-box">Response</div>
                    </div>
                </div>
            </section>
            
            <section id="architecture" class="section">
                <h2>Architecture Components</h2>
                
                <div class="collapsible">
                    <div class="collapsible-header">Core Components</div>
                    <div class="collapsible-content">
                        <h4>1. LlmAgent - Individual AI Worker</h4>
                        <p>Each LlmAgent is like hiring a specialist employee. You give them specific instructions, tools they can use, and they focus on one type of task.</p>
                        
                        <h4>2. LoopAgent/SequentialAgent - Team Manager</h4>
                        <p>These orchestrate multiple agents, deciding when and how they should work together.</p>
                        
                        <h4>3. MCPToolset - External Capabilities</h4>
                        <p>Connects your agents to external services like databases, APIs, calculators, etc.</p>
                        
                        <h4>4. Cooldown System - Usage Control</h4>
                        <p>Prevents spam and manages resource usage by tracking when agents were last used.</p>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <h4>🔧 Interactive Architecture Demo</h4>
                    <p>Click components to see their role:</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 15px;">
                        <button class="button" onclick="showArchDemo('user')">User Input</button>
                        <button class="button" onclick="showArchDemo('cooldown')">Cooldown Check</button>
                        <button class="button" onclick="showArchDemo('agent1')">First Agent</button>
                        <button class="button" onclick="showArchDemo('agent2')">Second Agent</button>
                        <button class="button" onclick="showArchDemo('tools')">External Tools</button>
                    </div>
                    <div id="arch-demo-output" class="output-box" style="margin-top: 15px; min-height: 60px;">
                        Click any component above to see its role in the system...
                    </div>
                </div>
            </section>
            
            <section id="configuration" class="section">
                <h2>Configuration Setup</h2>
                
                <div class="code-explanation">
                    <div class="code-side">
                        <h3>Environment Variables</h3>
                        <div class="code-block">
<span class="syntax-comment"># .env file</span>
<span class="syntax-keyword">API_SERVER_URL</span>=http://your-server.com
<span class="syntax-keyword">FUNCTION_TOOLS_URL</span>=http://tools.com
<span class="syntax-keyword">PUBLIC_URL</span>=http://your-domain.com
                        </div>
                    </div>
                    <div class="explanation-side">
                        <h3>What Each Variable Does</h3>
                        <p><strong>API_SERVER_URL:</strong> Where your cooldown tracking service runs. This prevents users from calling your agents too frequently.</p>
                        <p><strong>FUNCTION_TOOLS_URL:</strong> URL of your MCP tools server that provides external functions your agents can call.</p>
                        <p><strong>PUBLIC_URL:</strong> The public address where your agent system can be accessed from the internet.</p>
                        
                        <div class="warning-box">
                            <strong>Security Note:</strong> Keep these URLs in a .env file, never hardcode them in your source code.
                        </div>
                    </div>
                </div>
                
                <div class="collapsible">
                    <div class="collapsible-header">Configuration Code Walkthrough</div>
                    <div class="collapsible-content">
                        <div class="code-block">
<span class="syntax-comment"># Load environment variables from .env file</span>
<span class="syntax-keyword">from</span> dotenv <span class="syntax-keyword">import</span> load_dotenv
load_dotenv()

<span class="syntax-comment"># Set cooldown period (in seconds)</span>
<span class="syntax-keyword">COOLDOWN_PERIOD_SECONDS</span> = <span class="syntax-number">60</span>

<span class="syntax-comment"># Get URLs from environment</span>
<span class="syntax-keyword">COOLDOWN_API_URL</span> = os.environ.get(<span class="syntax-string">"API_SERVER_URL"</span>)
<span class="syntax-keyword">FUNCTION_TOOLS_URL</span> = os.environ.get(<span class="syntax-string">"FUNCTION_TOOLS_URL"</span>)
                        </div>
                        
                        <p>This section loads your secret URLs and sets the cooldown timer. The cooldown prevents users from overwhelming your system with requests.</p>
                    </div>
                </div>
            </section>
            
            <section id="cooldown" class="section">
                <h2>Cooldown System Deep Dive</h2>
                
                <p>The cooldown system is like a bouncer at a club - it controls who gets in and when. Here's how it works:</p>
                
                <div class="diagram">
                    <h3>Cooldown Flow</h3>
                    <div class="flow-diagram">
                        <div class="flow-box">Agent Called</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-box">Check Last Usage</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-box" style="background: #e74c3c;">Too Soon?<br>Block</div>
                        <div class="flow-arrow" style="transform: rotate(180deg);">→</div>
                        <div class="flow-box" style="background: #27ae60;">OK?<br>Allow & Update</div>
                    </div>
                </div>
                
                <div class="collapsible">
                    <div class="collapsible-header">Cooldown Function Explanation</div>
                    <div class="collapsible-content">
                        <div class="code-explanation">
                            <div class="code-side">
                                <div class="code-block">
<span class="syntax-keyword">def</span> <span class="syntax-python">check_cool_down</span>(callback_context):
    agent_name = callback_context.agent_name
    
    <span class="syntax-comment"># Check when agent was last used</span>
    response = requests.get(
        f<span class="syntax-string">"{COOLDOWN_API_URL}/cooldown/{agent_name}"</span>
    )
    
    <span class="syntax-keyword">if</span> too_recent:
        <span class="syntax-keyword">return</span> <span class="syntax-string">"Please wait X seconds"</span>
    
    <span class="syntax-comment"># Update timestamp</span>
    requests.post(
        f<span class="syntax-string">"{COOLDOWN_API_URL}/cooldown/{agent_name}"</span>,
        json={<span class="syntax-string">"timestamp"</span>: now}
    )
    
    <span class="syntax-keyword">return</span> <span class="syntax-keyword">None</span>  <span class="syntax-comment"># Allow agent to run</span>
                                </div>
                            </div>
                            <div class="explanation-side">
                                <h3>Step-by-Step Process</h3>
                                <ol>
                                    <li><strong>Get Agent Name:</strong> Which agent is trying to run?</li>
                                    <li><strong>Check API:</strong> When was this agent last used?</li>
                                    <li><strong>Calculate Time:</strong> Has enough time passed?</li>
                                    <li><strong>Block or Allow:</strong> Return error message or None</li>
                                    <li><strong>Update Timestamp:</strong> Record current usage time</li>
                                </ol>
                                
                                <div class="info-box">
                                    <strong>Return Values:</strong><br>
                                    • <code>None</code> = Let agent run<br>
                                    • <code>Content(...)</code> = Block with message
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <h4>🕒 Cooldown Simulator</h4>
                    <p>Test how the cooldown system works:</p>
                    <input type="number" id="cooldown-seconds" class="demo-input" placeholder="Cooldown period (seconds)" value="30">
                    <button class="button" onclick="simulateCooldown()">Call Agent</button>
                    <div id="cooldown-result" class="output-box" style="margin-top: 10px;">
                        Ready to test cooldown system...
                    </div>
                </div>
            </section>
            
            <section id="tools" class="section">
                <h2>Tool Setup & Integration</h2>
                
                <p>Tools are external services that give your agents superpowers. Think of them as apps on a smartphone - each tool does something specific that your agents can use.</p>
                
                <div class="code-explanation">
                    <div class="code-side">
                        <h3>MCP Toolset Setup</h3>
                        <div class="code-block">
<span class="syntax-comment"># Create toolset connection</span>
toolFunction = <span class="syntax-python">MCPToolset</span>(
    connection_params=<span class="syntax-python">SseServerParams</span>(
        url=<span class="syntax-keyword">FUNCTION_TOOLS_URL</span>,
        headers={}  <span class="syntax-comment"># Authentication if needed</span>
    )
)

<span class="syntax-comment"># Add toolset to agents that need it</span>
agent = <span class="syntax-python">LlmAgent</span>(
    model=<span class="syntax-string">'gemini-2.5-flash'</span>,
    name=<span class="syntax-string">'tool_user'</span>,
    instruction=<span class="syntax-string">"Use tools to help users"</span>,
    tools=[toolFunction]  <span class="syntax-comment"># Give agent access</span>
)
                        </div>
                    </div>
                    <div class="explanation-side">
                        <h3>Understanding Tools</h3>
                        <p><strong>What are MCP Tools?</strong> Model Context Protocol tools are external functions your AI agents can call, like:</p>
                        <ul>
                            <li>🌤️ Weather APIs</li>
                            <li>🗄️ Database queries</li>
                            <li>🧮 Calculators</li>
                            <li>📧 Email senders</li>
                            <li>🔍 Web scrapers</li>
                        </ul>
                        
                        <div class="success-box">
                            <strong>Best Practice:</strong> Only give tools to agents that actually need them. Not every agent needs every tool.
                        </div>
                    </div>
                </div>
                
                <div class="collapsible">
                    <div class="collapsible-header">Tool Examples & Use Cases</div>
                    <div class="collapsible-content">
                        <h4>Common Tool Patterns:</h4>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                            <div class="info-box">
                                <h5>🎯 Data Processing Agent</h5>
                                <p><strong>Tools needed:</strong> Database connector, CSV processor, chart generator</p>
                                <p><strong>Use case:</strong> Takes user data, cleans it, stores it, creates visualizations</p>
                            </div>
                            
                            <div class="info-box">
                                <h5>🤖 Customer Support Agent</h5>
                                <p><strong>Tools needed:</strong> Knowledge base searcher, ticket creator, email sender</p>
                                <p><strong>Use case:</strong> Answers questions, creates support tickets, sends follow-ups</p>
                            </div>
                            
                            <div class="info-box">
                                <h5>📊 Research Agent</h5>
                                <p><strong>Tools needed:</strong> Web scraper, PDF reader, data analyzer</p>
                                <p><strong>Use case:</strong> Gathers information from multiple sources, analyzes findings</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="agents" class="section">
                <h2>Creating Intelligent Agents</h2>
                
                <p>Agents are the heart of your system. Each agent is like hiring a specialist employee with specific skills and responsibilities.</p>
                
                <div class="collapsible">
                    <div class="collapsible-header">Agent Anatomy</div>
                    <div class="collapsible-content">
                        <div class="code-explanation">
                            <div class="code-side">
                                <div class="code-block">
first_agent = <span class="syntax-python">LlmAgent</span>(
    <span class="syntax-comment"># Choose AI model</span>
    model=<span class="syntax-string">'gemini-2.5-flash'</span>,
    
    <span class="syntax-comment"># Unique identifier</span>
    name=<span class="syntax-string">'data_processor'</span>,
    
    <span class="syntax-comment"># Detailed job description</span>
    instruction=<span class="syntax-string">"""
    You are a data processor. Your job:
    1. Take user's raw data
    2. Clean and validate it
    3. Use 'process_data' tool
    4. Return only the results
    """</span>,
    
    <span class="syntax-comment"># Tools this agent can use</span>
    tools=[toolFunction]
)
                                </div>
                            </div>
                            <div class="explanation-side">
                                <h3>Agent Components Explained</h3>
                                <p><strong>Model:</strong> The AI brain (GPT-4, Claude, Gemini, etc.)</p>
                                <p><strong>Name:</strong> Used in logs and API calls. Keep it descriptive but short.</p>
                                <p><strong>Instruction:</strong> The most important part! This is the agent's job description. Be very specific about:</p>
                                <ul>
                                    <li>What input the agent receives</li>
                                    <li>What steps it should take</li>
                                    <li>Which tools to use and how</li>
                                    <li>What output format is expected</li>
                                </ul>
                                <p><strong>Tools:</strong> List of external functions this agent can call</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <h4>🧠 Agent Instruction Builder</h4>
                    <p>Build custom instructions for your agent:</p>
                    
                    <input type="text" id="agent-role" class="demo-input" placeholder="Agent role (e.g., 'data analyst', 'customer support')">
                    <input type="text" id="agent-input" class="demo-input" placeholder="What input will it receive?">
                    <input type="text" id="agent-task" class="demo-input" placeholder="Main task to perform">
                    <input type="text" id="agent-output" class="demo-input" placeholder="Expected output format">
                    
                    <button class="button" onclick="buildInstruction()">Generate Instruction</button>
                    
                    <div id="instruction-result" class="output-box" style="margin-top: 15px;">
                        Fill in the fields above to generate a custom agent instruction...
                    </div>
                </div>
                
                <div class="collapsible">
                    <div class="collapsible-header">Multi-Agent Communication</div>
                    <div class="collapsible-content">
                        <p>When agents work together, the output of one becomes the input of the next. Here's how they communicate:</p>
                        
                        <div class="diagram">
                            <h4>Agent Communication Flow</h4>
                            <div class="flow-diagram">
                                <div class="flow-box">Agent 1<br><small>Processes input</small></div>
                                <div class="flow-arrow">→</div>
                                <div class="flow-box" style="background: #9b59b6;">Shared Context<br><small>Agent 1's output</small></div>
                                <div class="flow-arrow">→</div>
                                <div class="flow-box">Agent 2<br><small>Uses context</small></div>
                            </div>
                        </div>
                        
                        <div class="info-box">
                            <strong>Communication Tips:</strong><br>
                            • Agent 1 should output clean, structured data<br>
                            • Agent 2 should expect and handle Agent 1's output format<br>
                            • Use output_key to save important results<br>
                            • Test agent handoffs thoroughly
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="orchestration" class="section">
                <h2>Orchestration Patterns</h2>
                
                <p>Orchestration decides how your agents work together. It's like choosing between a relay race (sequential) or multiple laps (loop).</p>
                
                <div class="collapsible">
                    <div class="collapsible-header">LoopAgent - Iterative Processing</div>
                    <div class="collapsible-content">
                        <div class="code-explanation">
                            <div class="code-side">
                                <div class="code-block">
root_agent = <span class="syntax-python">LoopAgent</span>(
    name=<span class="syntax-string">"iterative_system"</span>,
    sub_agents=[agent1, agent2],
    max_iterations=<span class="syntax-number">3</span>,  <span class="syntax-comment"># Run 3 times</span>
    description=<span class="syntax-string">"Refines results through multiple passes"</span>
)
                                </div>
                            </div>
                            <div class="explanation-side">
                                <h3>When to Use LoopAgent</h3>
                                <ul>
                                    <li><strong>Iterative refinement:</strong> Each pass improves the result</li>
                                    <li><strong>Quality improvement:</strong> Multiple reviews catch more issues</li>
                                    <li><strong>Creative processes:</strong> Brainstorm → Refine → Polish</li>
                                </ul>
                                
                                <p><strong". this is the original python code for refrence. "# ============================================================================
# AGENT TEMPLATE - Multi-Agent System with Cooldown and MCP Tools
# ============================================================================
# This template helps you create your own multi-agent system based on Google ADK
# Follow the comments to customize each section for your specific use case
# ============================================================================

# --- IMPORTS SECTION ---
# These are the libraries we need to make our agent system work

import asyncio  # For handling multiple tasks at once
import os  # For reading environment variables
from contextlib import AsyncExitStack  # For managing async resources
from dotenv import load_dotenv  # For loading .env files
from google.adk.agents.llm_agent import LlmAgent  # Single AI agent
from google.adk.agents.loop_agent import LoopAgent  # Agent that runs multiple times
from google.adk.agents.sequential_agent import SequentialAgent  # Agents that run one after another
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset  # External tools your agents can use
from google.adk.tools.mcp_tool.mcp_session_manager import SseServerParams  # Tool connection settings
import logging   # For printing debug messages
import nest_asyncio   # For running async code in notebooks
from typing import Optional  # For type hints
from google.genai import types  # Google AI types
import requests  # For making web API calls
from datetime import datetime, timezone, timedelta  # For handling time
from toolbox_core import ToolboxSyncClient  # Toolbox integration
from google.adk.agents.callback_context import CallbackContext  # Info about running agents

# ============================================================================
# CONFIGURATION SECTION - CUSTOMIZE THESE VALUES
# ============================================================================

# Load environment variables from .env file (secrets and URLs go here)
load_dotenv()

# --- COOLDOWN CONFIGURATION ---
# This prevents your agents from being called too often (like rate limiting)
# TODO: Set how many seconds to wait between agent runs
COOLDOWN_PERIOD_SECONDS = 60  # Change this number (60 = 1 minute wait)

# TODO: Set your cooldown API URL - this tracks when agents were last used
# Put this URL in your .env file as API_SERVER_URL=http://your-server.com
COOLDOWN_API_URL = os.environ.get("API_SERVER_URL")  # Gets URL from .env file
print(f"COOLDOWN_API_URL: {COOLDOWN_API_URL}")  # Shows what URL we're using

# --- TOOL CONFIGURATION ---
# Tools are external services your agents can call (like calculators, databases, etc.)
# TODO: Set your MCP tools server URL - where your tools live
FUNCTION_TOOLS_URL = os.environ.get("FUNCTION_TOOLS_URL")  # Gets from .env file

# TODO: Set your public URL - how others can access your agent
PUBLIC_URL = os.environ.get("PUBLIC_URL")  # Gets from .env file

# Print the URLs so you can see what's configured
print(f"FUNCTION_TOOLS_URL: {FUNCTION_TOOLS_URL}")
print(f"PUBLIC_URL: {PUBLIC_URL}")

# --- LOGGING CONFIGURATION ---
# This controls what debug messages get printed
logging.basicConfig(level=logging.INFO)  # INFO level shows important messages
log = logging.getLogger(__name__)  # Creates a logger for this file

# --- GLOBAL VARIABLES ---
# These will hold our main agent and resources, start as None
root_agent: LlmAgent | None = None  # Will hold our main agent
exit_stack: AsyncExitStack | None = None  # Will manage resources

# ============================================================================
# COOLDOWN CALLBACK FUNCTION - PREVENTS OVERUSE OF AGENTS
# ============================================================================

def check_cool_down(callback_context: CallbackContext) -> Optional[types.Content]:
    """
    This function runs before each agent to check if it's been used too recently.
    
    HOW IT WORKS:
    1. Checks external API to see when agent was last used
    2. If too recent, blocks the agent and sends error message
    3. If okay, updates timestamp and lets agent run
    
    HOW TO CUSTOMIZE:
    - Change COOLDOWN_PERIOD_SECONDS at the top for different wait times
    - Modify the error message text below
    - Add your own checking logic if needed
    
    Args:
        callback_context: Info about which agent is trying to run
        
    Returns:
        None = let agent run, Content = block agent with this message
    """
    # Get the name of the agent that's trying to run
    agent_name = callback_context.agent_name
    print(f"[Callback] Before '{agent_name}': Checking cooldown status...")

    # --- 1. CHECK the Cooldown API ---
    # Ask external service when this agent was last used
    try:
        # Make web request to check last usage time
        response = requests.get(f"{COOLDOWN_API_URL}/cooldown/{agent_name}")
        response.raise_for_status()  # Throw error if request failed
        data = response.json()  # Parse JSON response
        last_used_str = data.get("time")  # Get the timestamp
    except requests.exceptions.RequestException as e:
        # If API is down, print error but let agent run anyway
        print(f"[Callback] ERROR: Could not reach Cooldown API. Allowing agent to run. Reason: {e}")
        return None  # None means "let the agent run"

    # --- 2. EVALUATE the Cooldown Status ---
    # Check if enough time has passed since last use
    if last_used_str:  # If we have a last-used timestamp
        # Convert string timestamp to datetime object
        last_used_time = datetime.fromisoformat(last_used_str)
        # Calculate how much time has passed
        time_since_last_use = datetime.now(timezone.utc) - last_used_time

        # If not enough time has passed, block the agent
        if time_since_last_use < timedelta(seconds=COOLDOWN_PERIOD_SECONDS):
            # Calculate how many seconds left to wait
            seconds_remaining = int(COOLDOWN_PERIOD_SECONDS - time_since_last_use.total_seconds())
            
            # TODO: Customize this message for your agent's personality
            override_message = (
                f"The {agent_name} is on cooldown and cannot be used right now. "
                f"Please wait {seconds_remaining} seconds before trying again."
            )
            print(f"[Callback] Cooldown active for '{agent_name}'. Terminating with message.")
            # Return a message to user instead of running agent
            return types.Content(parts=[types.Part(text=override_message)])

    # --- 3. UPDATE the Cooldown API ---
    # If we get here, agent is allowed to run, so record the current time
    current_time_iso = datetime.now(timezone.utc).isoformat()  # Get current time as string
    payload = {"timestamp": current_time_iso}  # Package as JSON
    
    print(f"[Callback] '{agent_name}' is available. Updating timestamp via Cooldown API...")
    try:
        # Send current time to API to record this usage
        requests.post(f"{COOLDOWN_API_URL}/cooldown/{agent_name}", json=payload)
    except requests.exceptions.RequestException as e:
        # If update fails, print error but still let agent run
        print(f"[Callback] ERROR: Could not update timestamp, but allowing agent to run. Reason: {e}")

    # --- 4. ALLOW the agent to run ---
    print(f"[Callback] Check complete for '{agent_name}'. Proceeding with execution.")
    return None  # None means "proceed with agent execution"

# ============================================================================
# TOOL SETUP - EXTERNAL FUNCTIONS YOUR AGENTS CAN USE
# ============================================================================

# TODO: Replace with your own tools setup
# MCP (Model Context Protocol) lets agents call external functions
toolFunction = MCPToolset(
    # Connection settings for your tools server
    connection_params=SseServerParams(
        url=FUNCTION_TOOLS_URL,  # Where your tools server is running
        headers={}  # Any special headers needed (usually empty)
    )
)

# TODO: Add more tools if you need them
# Example of adding another toolset:
# database_tools = MCPToolset(
#     connection_params=SseServerParams(url=DATABASE_TOOLS_URL, headers={})
# )

# ============================================================================
# AGENT DEFINITIONS - THE AI WORKERS THAT DO YOUR TASKS
# ============================================================================

# --- FIRST AGENT - THE PRIMARY WORKER ---
# TODO: Replace this entire agent with your own
first_agent = LlmAgent(
    # TODO: Pick your AI model (options: gemini-2.5-flash, gpt-4, claude-3, etc.)
    model='gemini-2.5-flash',
    
    # TODO: Give your agent a clear, descriptive name (no spaces)
    name='first_agent',  # This name appears in logs and API calls
    
    # TODO: Write detailed instructions for what this agent should do
    instruction="""
        REPLACE THIS ENTIRE INSTRUCTION BLOCK WITH YOUR AGENT'S JOB
        
        Be very specific about:
        - What task should this agent perform?
        - What input will it receive?
        - Which tools should it use and how?
        - What output should it produce?
        - Any rules or constraints?
        
        Example (DELETE THIS AND WRITE YOUR OWN):
        You are a data processor. Your job is to:
        1. Take the input data provided by the user
        2. Clean and validate the data
        3. Use the 'process_data' tool with the cleaned data
        4. Return only the tool's output, no additional text
    """,
    
    # TODO: List which tools this agent can use (remove if no tools needed)
    tools=[toolFunction]  # This agent can use the tools we set up above
)

# --- SECOND AGENT - THE ANALYZER/PROCESSOR ---
# TODO: Replace this entire agent with your own
second_agent = LlmAgent(
    # TODO: Pick your AI model (can be different from first agent)
    model='gemini-2.5-flash',
    
    # TODO: Give this agent its own descriptive name
    name='second_agent',
    
    # TODO: Write instructions for what this agent does with the first agent's output
    instruction="""
        REPLACE THIS ENTIRE INSTRUCTION BLOCK WITH YOUR AGENT'S JOB
        
        This agent typically:
        - Takes output from the first agent
        - Analyzes, formats, or validates it
        - Applies business logic
        - Prepares final response for user
        
        Example (DELETE THIS AND WRITE YOUR OWN):
        You are a results analyzer. Your job is to:
        1. Take the processed data from the previous step
        2. Generate insights and summaries
        3. Format the results in a user-friendly way
        4. Provide actionable recommendations
    """,
    
    # TODO: If this agent's output should be saved with a specific name, set output_key
    output_key="final_result"  # This saves the agent's response under this name
    # NOTE: Remove output_key line if you don't need to save this agent's output
)

# TODO: Add more agents if your workflow needs them
# Example of a third agent:
# validation_agent = LlmAgent(
#     model='gemini-2.5-flash',
#     name='validator',
#     instruction="You validate and quality-check the final results...",
#     tools=[toolFunction]  # Only include if this agent needs tools
# )

# ============================================================================
# ROOT AGENT - THE ORCHESTRATOR THAT MANAGES ALL OTHER AGENTS
# ============================================================================

# TODO: Choose your orchestration pattern and customize
# LoopAgent runs agents multiple times in a loop
root_agent = LoopAgent(
    # TODO: Name your overall system (this appears in API and logs)
    name="your_agent_system_name",  # Change to describe your system's purpose
    
    # TODO: List all agents in the order they should run
    sub_agents=[
        first_agent,    # Runs first each iteration
        second_agent    # Runs second each iteration
        # Add more agents here if needed
    ],
    
    # TODO: Set how many times the loop should run
    max_iterations=2,  # 2 means: run all agents, then run them again
    
    # TODO: Describe what your complete system accomplishes
    description="Describe what your multi-agent system does end-to-end.",
    
    # TODO: Add callbacks (functions that run before/after agents)
    before_agent_callback=check_cool_down  # Runs cooldown check before each agent
    # NOTE: Remove this line if you don't want cooldown checking
)

# ============================================================================
# ALTERNATIVE ORCHESTRATION PATTERNS - UNCOMMENT TO USE
# ============================================================================

# TODO: Use SequentialAgent if you want each agent to run only once, in order
# root_agent = SequentialAgent(
#     name="your_sequential_system",
#     sub_agents=[first_agent, second_agent],  # Each runs once, in order
#     description="Runs agents in sequence, each exactly once.",
#     before_agent_callback=check_cool_down  # Optional cooldown
# )

# TODO: Use single LlmAgent if you only need one AI agent
# root_agent = LlmAgent(
#     model='gemini-2.5-flash',
#     name='single_agent_system',
#     instruction="Complete instructions for your single agent...",
#     tools=[toolFunction],  # Optional tools
#     before_agent_callback=check_cool_down  # Optional cooldown
# )

# ============================================================================
# SERVER SETUP - TURNS YOUR AGENT INTO A WEB API
# ============================================================================

# Import the converter that turns agents into web APIs
from agent_to_a2a import to_a2a

# This runs when you start the script directly (not when importing it)
if __name__ == "__main__":
    import uvicorn  # Web server for Python
    
    # TODO: Customize server settings
    PORT = 8080  # Change if you need a different port number
    HOST = '0.0.0.0'  # '0.0.0.0' means accept connections from anywhere
    
    # Convert your agent system into a web API
    a2a_app = to_a2a(
        root_agent,     # The main agent system we built above
        port=PORT,      # Port number for the API
        public_url=PUBLIC_URL  # Public URL from environment variables
    )
    
    # Start the web server
    uvicorn.run(a2a_app, host=HOST, port=PORT)
    # After this runs, your agents will be available as a web API

# ============================================================================
# ENVIRONMENT VARIABLES NEEDED (.env file)
# ============================================================================
"""
Create a file called '.env' in the same folder as this script.
Put these variables in it (replace the URLs with your actual URLs):

# Optional: API server for tracking agent usage (prevents spam)
API_SERVER_URL=http://your-cooldown-server.com

# Required if using tools: Where your external tools/functions are hosted
FUNCTION_TOOLS_URL=http://your-tools-server.com

# Required for external access: Public URL where people can reach your agent
PUBLIC_URL=http://your-agent-domain.com

# Add any other secrets or URLs your specific agents need:
# DATABASE_URL=postgresql://user:pass@host:5432/dbname
# API_KEY=your-secret-api-key-here
# OPENAI_API_KEY=sk-your-openai-key-here
"""

# ============================================================================
# STEP-BY-STEP CUSTOMIZATION CHECKLIST
# ============================================================================
"""
TO MAKE THIS TEMPLATE WORK FOR YOUR USE CASE:

□ 1. BASIC SETUP
   - Create .env file with your URLs and secrets
   - Set COOLDOWN_PERIOD_SECONDS to your preferred wait time
   - Test that the script runs without errors

□ 2. REPLACE THE AGENTS
   - Change first_agent name and instructions for your primary task
   - Change second_agent name and instructions for your secondary task  
   - Add more agents if your workflow needs them
   - Remove agents you don't need

□ 3. CONFIGURE TOOLS (if needed)
   - Set up your MCP tools server
   - Update FUNCTION_TOOLS_URL in .env
   - Assign tools to the agents that need them
   - Test tool connections

□ 4. CHOOSE ORCHESTRATION
   - Keep LoopAgent if you want agents to run multiple times
   - Use SequentialAgent if agents should run once each, in order
   - Use single LlmAgent if you only need one agent

□ 5. CUSTOMIZE BEHAVIOR
   - Modify cooldown messages and timing
   - Add error handling for your specific use cases
   - Adjust logging levels if needed

□ 6. DEPLOYMENT
   - Set PORT and HOST for your environment
   - Configure PUBLIC_URL for external access
   - Test the complete system end-to-end

□ 7. TESTING CHECKLIST
   - Test each agent individually
   - Test agent-to-agent communication
   - Test cooldown functionality (try calling agents too quickly)
   - Test tool integrations
   - Test with real user input
"""

# ============================================================================
# COMPLETE EXAMPLE - WEATHER REPORTING SYSTEM
# ============================================================================
"""
Here's a complete example of how to fill out this template for a weather reporting system:

# 1. CONFIGURATION (top of file)
COOLDOWN_PERIOD_SECONDS = 30  # 30 second cooldown

# 2. FIRST AGENT - Weather Data Collector
weather_collector = LlmAgent(
    model='gemini-2.5-flash',
    name='weather_collector',
    instruction=\"\"\"
        You are a weather data collector. Your job is to:
        1. Take the city name provided by the user
        2. Use the 'get_weather_data' tool to fetch current weather
        3. Return only the raw weather data from the tool
        4. Do not add any formatting or commentary
    \"\"\",
    tools=[weather_tools]
)

# 3. SECOND AGENT - Weather Report Generator  
weather_reporter = LlmAgent(
    model='gemini-2.5-flash',
    name='weather_reporter',
    instruction=\"\"\"
        You are a friendly weather reporter. Your job is to:
        1. Take the raw weather data from the previous step
        2. Create a friendly, conversational weather report
        3. Include temperature, conditions, and a recommendation for what to wear
        4. Keep it under 100 words and make it engaging
    \"\"\",
    output_key="weather_report"
)

# 4. ROOT AGENT - Weather System
root_agent = LoopAgent(
    name="weather_reporting_system",
    sub_agents=[weather_collector, weather_reporter],
    max_iterations=1,  # Run each agent once
    description="Collects weather data and creates friendly weather reports.",
    before_agent_callback=check_cool_down
)

# 5. ENVIRONMENT VARIABLES (.env file)
API_SERVER_URL=http://localhost:3000
FUNCTION_TOOLS_URL=http://weather-tools.example.com
PUBLIC_URL=http://my-weather-bot.example.com

# 6. USAGE
# User sends: "Weather for New York"
# weather_collector gets weather data using tools
# weather_reporter creates: "Good morning! It's a sunny 72°F in New York today with clear skies. Perfect weather for a walk in the park! I'd recommend light clothing and maybe sunglasses. Enjoy your day!"
"""

# ============================================================================
# COMMON USE CASE EXAMPLES
# ============================================================================
"""
OTHER EXAMPLES OF HOW TO USE THIS TEMPLATE:

1. CUSTOMER SUPPORT SYSTEM
   - Agent 1: Analyzes customer inquiry and categorizes it
   - Agent 2: Searches knowledge base for relevant information  
   - Agent 3: Writes personalized response with solution

2. CONTENT CREATION PIPELINE
   - Agent 1: Researches topic and gathers information
   - Agent 2: Creates outline and structure
   - Agent 3: Writes full content with engaging language

3. DATA ANALYSIS WORKFLOW
   - Agent 1: Cleans and validates input data
   - Agent 2: Performs statistical analysis and calculations
   - Agent 3: Generates insights and visualization suggestions

4. E-COMMERCE ASSISTANT
   - Agent 1: Understands product requirements from user query
   - Agent 2: Searches product database and compares options
   - Agent 3: Makes personalized recommendations with reasoning

5. CODE REVIEW SYSTEM
   - Agent 1: Analyzes code for bugs and security issues
   - Agent 2: Checks code style and best practices
   - Agent 3: Generates comprehensive review report with suggestions

Each example would use the same template structure but with different:
- Agent instructions (what each agent does)
- Tools (external APIs/functions they can call)
- Orchestration (how agents work together)
- Output formatting (what users receive)
""""
